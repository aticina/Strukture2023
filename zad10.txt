10. Napisati program koji čita datoteku drzave.txt u kojoj su zapisani nazivi pojedinih država. Uz
ime države u datoteci se nalazi i ime dodatne datoteke u kojoj se nalaze gradovi pojedine
države. Svaka datoteka koja predstavlja državu sadrži popis gradova u formatu naziv_grada,
broj_stanovnika.
a) Potrebno je formirati sortiranu vezanu listu država po nazivu. Svaki čvor vezane liste
sadrži stablo gradova sortirano po broju stanovnika, zatim po nazivu grada.
b) Potrebno je formirati stablo država sortirano po nazivu. Svaki čvor stabla sadrži vezanu
listu gradova sortiranu po broju stanovnika, zatim po nazivu grada.
Nakon formiranja podataka potrebno je ispisati države i gradove te omogućiti korisniku putem
tastature pretragu gradova određene države koji imaju broj stanovnika veći od unosa na
tastaturi.

DAKLE,
PRVO ČITANJEM IZ FILEOVA RADIMO SORTIRANE STRUKTURE. (možda i to staviti u funkcije)
DRUGO FUNKCIJU ZA ISPIS CIJELIH STRUKTURA, PRONAĐI SVE GRADOVE KOJI IMAJU VIŠE STANOVNIKA OD UNESENE VRIJEDNOSTI(KORISNIK UNOSI VRIJEDNOST).

A)
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
#define MAX_CHAR 1024

struct country;
typedef struct country* c_Position;
typedef struct country{
    char name[MAX_CHAR];
    c_Position next;
} Country;

struct town;
typedef struct town* t_Position;
typedef struct town{
    int population;
    char name[MAX_CHAR];
    t_Position left;
    t_Position right;
} Town;

c_Position CreateCombinedStructure();//function that will call other functions in order to make connected list with tress as its members,automatically called from main and returns head of the list
int main(){
        CreateCombinedStructure();
return EXIT_SUCCESS;
}

c_Position CreateCombinedStructure(){

}
B)
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
#define MAX_CHAR 1024

struct country;
typedef struct country* c_Position;
typedef struct country{
    char name[MAX_CHAR];
    c_Position left;
    c_Position right;
} Country;

struct town;
typedef struct town* t_Position;
typedef struct town{
    int population;
    char name[MAX_CHAR];
    t_Position next;
} Town;

SA SATA!
#define FAILED_TO_MALLOC (NULL) -nande te yo..?
he made it so each struct can be both tree and list-dubious decision memorywise, but flexy
in something we got Position TownHead or TownRoot in country struct
readandfillcountriedfunction,createnewcountryfrombufferfunction,inserttownafterfunction(town position current one, townposition new one),insertnewtowntreefunction,insertsortednewtownlist,insertsortednewcounttrylistfunction,priintftowntreeinorderfunction(townposition townroottree)

ploča: files in files sorta
države.txt
    hrvstaka hrv.txt
        splid 20 000
        zadar 4 0000
    belgija bel.txt
        gent 3 000 000
        antherpend 10 000 000
stablo se prvo napravi pa se onda doda listi u njegovom kodu

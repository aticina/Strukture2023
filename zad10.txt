10. Napisati program koji čita datoteku drzave.txt u kojoj su zapisani nazivi pojedinih država. Uz
ime države u datoteci se nalazi i ime dodatne datoteke u kojoj se nalaze gradovi pojedine
države. Svaka datoteka koja predstavlja državu sadrži popis gradova u formatu naziv_grada,
broj_stanovnika.
a) Potrebno je formirati sortiranu vezanu listu država po nazivu. Svaki čvor vezane liste
sadrži stablo gradova sortirano po broju stanovnika, zatim po nazivu grada.
b) Potrebno je formirati stablo država sortirano po nazivu. Svaki čvor stabla sadrži vezanu
listu gradova sortiranu po broju stanovnika, zatim po nazivu grada.
Nakon formiranja podataka potrebno je ispisati države i gradove te omogućiti korisniku putem
tastature pretragu gradova određene države koji imaju broj stanovnika veći od unosa na
tastaturi.

DAKLE,
PRVO ČITANJEM IZ FILEOVA RADIMO SORTIRANE STRUKTURE. (možda i to staviti u funkcije)
DRUGO FUNKCIJU ZA ISPIS CIJELIH STRUKTURA, PRONAĐI SVE GRADOVE KOJI IMAJU VIŠE STANOVNIKA OD UNESENE VRIJEDNOSTI(KORISNIK UNOSI VRIJEDNOST).

A)
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
#define MAX_CHAR 1024

struct country;
typedef struct country* c_Position;
typedef struct country{
    char name[MAX_CHAR];
    c_Position next;
} Country;

struct town;
typedef struct town* t_Position;
typedef struct town{
    int population;
    char name[MAX_CHAR];
    t_Position left;
    t_Position right;
} Town;

c_Position CreateCombinedStructure();//function that will call other functions in order to make connected list with tress as its members,automatically called from main and returns head of the list
int main(){
        CreateCombinedStructure();
return EXIT_SUCCESS;
}

c_Position CreateCombinedStructure(){

}
B)
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
#define MAX_CHAR 1024

struct country;
typedef struct country* c_Position;
typedef struct country{
    char name[MAX_CHAR];
    c_Position left;
    c_Position right;
} Country;

struct town;
typedef struct town* t_Position;
typedef struct town{
    int population;
    char name[MAX_CHAR];
    t_Position next;
} Town;

SA SATA!
#define FAILED_TO_MALLOC (NULL) -nande te yo..?
he made it so each struct can be both tree and list-dubious decision memorywise, but flexy
in something we got Position TownHead or TownRoot in country struct
readandfillcountriedfunction,createnewcountryfrombufferfunction,inserttownafterfunction(town position current one, townposition new one),insertnewtowntreefunction,insertsortednewtownlist,insertsortednewcounttrylistfunction,priintftowntreeinorderfunction(townposition townroottree)

ploča: files in files sorta
države.txt
    hrvstaka hrv.txt
        splid 20 000
        zadar 4 0000
    belgija bel.txt
        gent 3 000 000
        antherpend 10 000 000
stablo se prvo napravi pa se onda doda listi u njegovom kodu
----------------------first draft, a bad one at that-------------
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
#define MALLOC_FAIL (NULL)
#define MAX_CHAR 1024

struct country;
typedef struct country* c_Position;
typedef struct country{
    char name[MAX_CHAR];
    c_Position next;
} Country;

struct town;
typedef struct town* t_Position;
typedef struct town{
    int population;
    char name[MAX_CHAR];
    t_Position left;
    t_Position right;
} Town;

c_Position MakeWholeStructure(c_Position);//first function to get called, it makes whole list-whose-memebers-are-tress thing before client inputs anything,it returns head of the list-whose-memebers-are-tress
//so I need it to do many things...let's first have it make a list by reading from a file, also this function will have many functions within itself
//1st read from country file and fill in all list memebers or am I buliding everything all at once as I go?
//Approach A: I make list, I go through list and make list-whose-memebers-are-tres
//Approach B: I makes 1st list memebers and its trees, I make 2nd list memeber and its trees
c_Position CreateListMember();
c_Position AddListMember(c_Position);

int main(){
    
    Country C_Head = {.name=" ",.next=NULL};
    
    MakeWholeStructure(&C_Head);
    
    return EXIT_SUCCESS;
}

c_Position MakeWholeStructure(c_Position c_current){
    
    FILE* c_fp;
    c_fp=fopen("countries.txt","r");
    if(!c_fp){
        printf("File countries.txt did not open!");
        return NULL;
    }
    
    while(!feof(c_fp)){
        
        c_Position c_new = (c_Position)malloc(sizeof(Country));
        if(!c_new){
            printf("Malloc did not work!");
            return MALLOC_FAIL;
        }
        c_new->name={0};
        c_new->next=NULL;
        
        fscanf(c_fp,"%s %*s",c_new->name);
        printf("Just a check, this should print country_name %s \n",c_new->name);
        
        while(c_current!=NULL){//we need to see where to add new element in preexisting list
        //strcmp==0 is impossible cause no two countries share the name
            if(strcmp(c_current->name,c_new->name)>0 && strcmp(c_current->next->name,c_new->name)<0){
                //this means we should add new member after current one
                c_new->next=c_current->next;
                c_current->next=c_new;
            }
            else{
                c_current=c_current->next;
            }
        }
        //after this while loop we know that newest element is part of the list know
        free(c_new); //I guess? Cause we did all we needed with it, it is part of list now, so bye bye temp dynamic memory
    }
    //after this while we have a list with countires, but no trees
}
